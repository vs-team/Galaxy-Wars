module Landscape

open "UnityEngine.dll"
open UnityEngine

entity Gasstation = {
  inherit UnityGasstation
  RepairZonE : Repair
  GroupZombies : [GroupZombie]
  ZombieSpawnpoints : [Transform]
  Counter : int

  rule GroupZombies, Counter = 
    wait ZombieSpawnpoints.Count > 0 && RepairZonE.RepairProgressBar.Value.pspeed = 15
    if Counter <> ZombieSpawnpoints.Count then
      let zsp = ZombieSpawnpoints.[Counter]
      let t = zsp.position
      let newZ = [new GroupZombie(t,2)]
      yield GroupZombies @ newZ, Counter + 1
      wait 2.0f
    else
      yield GroupZombies, 0

  rule ZombieSpawnpoints = 
    let x = 
      [for a in SP2 do
       select a]
    yield x
    wait false

  rule world.Jeep.Value.Destroyed, world.Jeep, world.Jeep.Value.CollisionWithModel, Destroyed = 
    wait world.Jeep.Value.CollisionWithModel
    let pos = modely.transform.position
    let newt = new Truck("zpickup", pos, false, [4;2;1;3])
    yield true, Some (newt), false, true
    yield world.Jeep.Value.Destroyed, world.Jeep, world.Jeep.Value.CollisionWithModel, Destroyed

  rule world.Jeep.Value.CollisionWithModel = 
    yield world.Jeep.Value.CollisionWithModel

  Create(ps : Vector3) = {
    Base = UnityGasstation.Instantiate(ps)
    RepairZonE = new Repair(ps)
    GroupZombies = []
    ZombieSpawnpoints = []
    Counter = 0
  }
}
entity Repair = {
  inherit UnityCheckpoint
  RepairProgressBar : Option<ProgressBar_1>
  Refill_Resources : bool

  rule Refill_Resources = 
    wait Refill_Resources <> false
    yield true
    yield false

  rule RepairProgressBar.Value.Destroyed, RepairProgressBar, Refill_Resources = 
    wait RepairProgressBar.IsSome
    if RepairProgressBar.Value.Finished then
      Debug.Log("finished all. add resources now")
      yield true, None, true

  rule RepairProgressBar.Value.startprogress, RepairProgressBar.Value.pspeed = 
    wait world.Jeep.IsSome
    wait RepairProgressBar.IsSome
    let axl = world.Jeep.Value.AxleInfos
    if axl.Count > 0 then
      let wheel = 
        [for a in axl do
         where (a.motor)
         select a.leftWheel]
      let bo = if wheel.Head.motorTorque < -40.0f || wheel.Head.motorTorque > 40.0f then false else true
      if isEntered && bo then
        yield true, 15
      else
        if isEntered then
          yield false, 50
        else
          yield false, 40

  rule RepairProgressBar.Value.startprogress, RepairProgressBar.Value.pspeed = 
    yield false, 101
    wait false

  Create(p : Vector3) = {
    Base = UnityCheckpoint.Find(p)
    RepairProgressBar = Some (new ProgressBar_1(1))
    Refill_Resources = false
  }
}
entity ProgressBar_1 = {
  inherit ProgressBarBehaviour
  num : int

  Create(j : int)=
  {
    Base = ProgressBar.ProgressBarBehaviour.Instantiate()
    num = j
  }
}

entity Landscape = { //here are the zombies created and destroyed after a frame
  inherit UnityLandscape
  Group : [GroupZombie]
  PickUps : [PickUp]
  Spawnpoints : [Transform]

  rule Group, PickUps, Spawnpoints = // spawning multiple groups on a single landscape
    wait Spawnpoints.Count > 0
    let random_spawnp = Random.Range(0,4) 
    let random_pickup = Random.Range(0,4)
    if random_spawnp <> random_pickup then
      let sps = Spawnpoints.[random_spawnp]
      let sps_pos = sps.position
      let rpu = Spawnpoints.[random_pickup]
      let rpu_pos = rpu.position
      yield [new GroupZombie(sps_pos,7);new GroupZombie(rpu_pos, 7)], [], []//, [new PickUp(rpu_pos1)], []
      wait false
    else 
      let sps1 = Spawnpoints.[1]
      let sps_pos1 = sps1.position
      let rpu1 = Spawnpoints.[2]
      let rpu_pos1 = rpu1.position
      yield [new GroupZombie(sps_pos1,7)], [new PickUp(rpu_pos1)], []
      wait false

  rule Spawnpoints = 
    let sps = 
      [for a in Spawnpoints2 do
       select a]
    yield sps
    wait false

  Create(pos : Vector3, ps : int) =
  {
  Base = UnityLandscape.Instantiate(pos, ps)
  Spawnpoints = []
  Group = []
  PickUps = []
  }
}

entity PickUp = {
  inherit UnityPickUp
  BonusAndResources : [BonusAndResource]
  BARpos : Vector3

  rule BonusAndResources = 
    let amount = 
      [for a in BonusAndResources do
       where (a.Destroyed = false)
       select a]
    yield amount

  rule BonusAndResources = 
    wait Shuffled.Count > 0
    let p0 = BARpos + new Vector3(0.0f,1.0f,0.0f)
    let p1 = BARpos - new Vector3(2.0f,-1.0f,0.0f)
    let p2 = BARpos + new Vector3(2.0f,1.0f,0.0f)
    let p3 = BARpos - new Vector3(4.0f,-1.0f,0.0f)
    let plist = [p0;p1;p2;p3]
    let Slist = Shuffled
    let BAR = 
      [for a in [0..3] do
       select (new BonusAndResource(plist.[a], Slist.[a]))]
    yield BAR
    wait false

  rule Shuffled = 
    let BARlist = ["AmmoBox";"Crossed Wrenches Red";"Medipack Red";"Battery Black";"Jerry Can Green";"Lightning Blue";"Arrows Green";"Bomb Red";"Shield Metal";"Star Red"]
    yield BARlist
    wait false

  Create(pos : Vector3) = 
  {
    BARpos = pos
    BonusAndResources = []
  }
}
entity BonusAndResource = {
  inherit UnityBonusResource
  NameOfBoR : string
  Active : bool

  rule Active, Destroyed = 
    if collids then 
      yield true, false
      yield true, true

  Create(pos : Vector3, bonus : string) = 
  {
    Base = UnityBonusResource.Instantiate(pos,bonus)
    NameOfBoR = bonus
    Active = false;
  }
}