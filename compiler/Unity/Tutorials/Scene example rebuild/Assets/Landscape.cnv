module Landscape

open "UnityEngine.dll"
open UnityEngine

entity Gasstation = {
  inherit UnityGasstation
  RepairZonE : Repair
  GroupZombies : [GroupZombie]
  ZombieSpawnpoints : [Transform]
  Barrels : [Barrel]
  Counter : int

  rule GroupZombies, Counter = 
    wait RepairZonE.RepairProgressBar.IsSome
    wait ZombieSpawnpoints.Count > 0 && RepairZonE.RepairProgressBar.Value.pspeed = 15
    if Counter <> ZombieSpawnpoints.Count then
      let zsp = ZombieSpawnpoints.[Counter]
      let t = zsp.position
      let newZ = [new GroupZombie(t,2)]
      yield GroupZombies @ newZ, Counter + 1
      wait 2.0f
    else
      yield GroupZombies, 0
        
  rule ZombieSpawnpoints = 
    let x = 
      [for a in SP2 do
       select a]
    yield x
    wait false

  rule world.Jeep.Value.Destroyed, world.Jeep, world.Jeep.Value.CollisionWithModel, Destroyed = 
    wait world.Jeep.Value.CollisionWithModel
    let pos = modely.transform.position
    let newt = new Truck("zpickup", pos, false, [4;2;1;3])
    yield true, Some (newt), false, true
    yield world.Jeep.Value.Destroyed, world.Jeep, world.Jeep.Value.CollisionWithModel, Destroyed

  rule world.Jeep.Value.CollisionWithModel = 
    yield world.Jeep.Value.CollisionWithModel

  rule Barrels =
    let x =
      [for a in Barrels do
       where (not a.Destroyed)
       select a]
    yield x

  rule Barrels = 
    let x = 
      [for a in Blocations do
       select (new Barrel(a))]
    yield x
    wait false
    
  Create(ps : Vector3) = {
    Base = UnityGasstation.Instantiate(ps)
    RepairZonE = new Repair(ps)
    GroupZombies = []
    ZombieSpawnpoints = []
    Barrels = []
    Counter = 0
  }
}

entity Repair = {
  inherit UnityCheckpoint
  RepairProgressBar : Option<ProgressBar_1>
  Refill_Resources : bool

  rule Refill_Resources = 
    wait Refill_Resources <> false
    yield true
    yield false

  rule RepairProgressBar.Value.Destroyed, RepairProgressBar, Refill_Resources = 
    wait RepairProgressBar.IsSome
    if RepairProgressBar.Value.Finished then
      yield true, None, true

  rule RepairProgressBar.Value.startprogress, RepairProgressBar.Value.pspeed = 
    wait world.Jeep.IsSome
    wait RepairProgressBar.IsSome
    let axl = world.Jeep.Value.AxleInfos
    if axl.Count > 0 then
      let wheel = 
        [for a in axl do
         where (a.motor)
         select a.leftWheel]
      let bo = if wheel.Head.motorTorque < -40.0f || wheel.Head.motorTorque > 40.0f then false else true
      if isEntered && bo then
        yield true, 15
      else
        if isEntered then
          yield false, 50
        else
          yield false, 40

  rule RepairProgressBar.Value.startprogress, RepairProgressBar.Value.pspeed = 
    yield false, 101
    wait false

  Create(p : Vector3) = {
    Base = UnityCheckpoint.Find(p)
    RepairProgressBar = Some (new ProgressBar_1(1))
    Refill_Resources = false
  }
}

entity Barrel = {
  inherit explode
  Health : float

  rule Destroyed = 
    wait Explode 
    yield true

  rule Explode = 
    wait Health < 0.1f
    yield true
    wait false

  rule Health, isHit = 
    wait isHit
    yield Health - 10.0f, false
    yield Health, false

  Create(ps : Vector3) =
  let r = Random.Range(1,3)
  {
    Base = explode.instantiate(ps, r)
    Health = 20.0f
  }
}

entity ProgressBar_1 = {
  inherit ProgressBarBehaviour
  num : int

  Create(j : int)=
  {
    Base = ProgressBar.ProgressBarBehaviour.Instantiate()
    num = j
  }
}

entity Landscape = { //here are the zombies created and destroyed after a frame
  inherit UnityLandscape
  Group : [GroupZombie]
  PickUps : [PickUp]
  Spawnpoints : [Transform]
  Streetlights_cnv : [Streetlight]
  Groupsize : int

  rule Group, PickUps, Spawnpoints = // spawning multiple groups on a single landscape
    wait Spawnpoints.Count > 0
    wait dt
    let random_spawnp = Random.Range(0,4) 
    let random_pickup = Random.Range(0,4)
    if random_spawnp <> random_pickup then
      let sps = Spawnpoints.[random_spawnp]
      let sps_pos = sps.position
      let rpu = Spawnpoints.[random_pickup]
      let rpu_pos = rpu.position
      if world.Score > 10000 then 
        let j = 
          [for a in [0..3] do
           where (a <> random_spawnp || a <> random_pickup)
           select a]
        let spo2 = Spawnpoints.[j.Head]
        let spo2_pos = spo2.position
        Debug.Log("Spawned 3 groups")
        yield [new GroupZombie(sps_pos,Groupsize);new GroupZombie(rpu_pos, Groupsize);new GroupZombie(spo2_pos, Groupsize)], [], []
        wait false
      else
        yield [new GroupZombie(sps_pos,Groupsize);new GroupZombie(rpu_pos, Groupsize)], [], []
        wait false
    else 
      let sps1 = Spawnpoints.[1]
      let sps_pos1 = sps1.position
      let sps0 = Spawnpoints.[0]
      let sps_pos0 = sps0.position
      let rpu1 = Spawnpoints.[2]
      let rpu_pos1 = rpu1.position
      if world.Score > 1000 then 
        yield [new GroupZombie(sps_pos1,Groupsize);new GroupZombie(sps_pos0,Groupsize)], [new PickUp(rpu_pos1, par)], []
        wait false
      else
        yield [new GroupZombie(sps_pos1,Groupsize)], [new PickUp(rpu_pos1, par)], []
        wait false

  rule Spawnpoints = 
    let sps = 
      [for a in Spawnpoints2 do
       select a]
    yield sps
    wait false

  rule Streetlights_cnv =
    let x =
      [for a in Streetlights_cnv do
       where (not a.Destroyed)
       select a]
    yield x

  rule Streetlights_cnv = 
    let r = Random.Range(0,Streetlights.Count)
    let p = Streetlights.[r]
    let z = p.Item1
    let b = if(p.Item2 = 1 || p.Item2 = 2) then 180.0f else 0.0f
    yield [new Streetlight(z, b, par)]
    wait false

  Create(pos : Vector3, ps : int) =
  {
  Base = UnityLandscape.Instantiate(pos, ps)
  Spawnpoints = []
  Group = []
  PickUps = []
  Streetlights_cnv = []
  Groupsize = 7
  }
}

entity Streetlight = {
  inherit UnityStreetLight
  test : bool

  rule test = 
    let r = Random.Range(0.2f, 0.9f)
    yield true
    wait r
    yield false
    wait r - 0.2f

  rule Lamp = 
    yield test

  Create(p : Transform, LeftSide : float, parent : Transform) = {
    Base = UnityStreetLight.instantiate(p,LeftSide, parent) // base cant be lower b. Otherwise Error at file 0
    test = false
  }
}

entity PickUp = {
  inherit UnityPickUp
  BonusAndResources : [BonusAndResource]
  BARpos : Vector3
  p : Transform

  rule BonusAndResources = 
    let amount = 
      [for a in BonusAndResources do
       where (a.Destroyed = false)
       select a]
    yield amount

  rule BonusAndResources = 
    wait Shuffled.Count > 0
    let p0 = BARpos + new Vector3(0.0f,1.0f,0.0f)
    let p1 = BARpos - new Vector3(2.0f,-1.0f,0.0f)
    let p2 = BARpos + new Vector3(2.0f,1.0f,0.0f)
    let p3 = BARpos - new Vector3(4.0f,-1.0f,0.0f)
    let plist = [p0;p1;p2;p3]
    let Slist = Shuffled
    let BAR = 
      [for a in [0..3] do
       select (new BonusAndResource(plist.[a], Slist.[a], p))]
    yield BAR
    wait false

  rule Shuffled = 
    let BARlist = ["AmmoBox";"Crossed Wrenches Red";"Medipack Red";"Battery Black";"Jerry Can Green";"Lightning Blue";"Arrows Green";"Star Red"]
    yield BARlist
    wait false

  Create(pos : Vector3, parent : Transform) = 
  {
    p = parent
    BARpos = pos
    BonusAndResources = []
  }
}
entity BonusAndResource = {
  inherit UnityBonusResource
  NameOfBoR : string
  Active : bool

  rule Active, Destroyed = 
    if collids then 
      yield true, false
      yield true, true

  Create(pos : Vector3, bonus : string, parent : Transform) = 
  {
    Base = UnityBonusResource.Instantiate(pos,bonus, parent)
    NameOfBoR = bonus
    Active = false;
  }
}